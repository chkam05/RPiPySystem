; Establishes a Unix socket for communication between supervisord and the supervisorctl tool (CLI client).
; This allows you to control services (supervisorctl status, supervisorctl restart, etc.)
[unix_http_server]
file=%(ENV_SUPERVISOR_SOCK)s                    ; Use a per-user UNIX socket path exported by tty/launch.sh
chmod=0600                                      ; Restrict access so only the owner can use supervisorctl/XML-RPC
;                                               ; EXACT file mode (octal). Sets the FINAL permissions of the UNIX socket/file (NOT a mask, unlike umask).
;                                               ; Mask Explanation:
;                                               ; Full umask can have FOUR octal digits: D A B C
;                                               ;   D = SPECIAL BITS MASK (setuid/setgid/sticky), rarely used → usually 0
;                                               ;   A = OWNER mask, B = GROUP mask, C = OTHERS mask
;                                               ; Value Explanation:
;                                               ;   0 -> ---    (no permissions)
;                                               ;   1 -> --x    (execute/search only)
;                                               ;   2 -> -w-    (write only)
;                                               ;   3 -> -wx    (write + execute_)
;                                               ;   4 -> r--    (read only)
;                                               ;   5 -> r-x    (read + execute)
;                                               ;   6 -> rw-    (read + write)
;                                               ;   7 -> rwx    (read + write + execute)
;                                               ; First digit (D) — SPECIAL BITS:
;                                               ;   sum of: setuid(4) + setgid(2) + sticky(1). Usually 0. Example: 0600 (no special bits).
chown=%(ENV_RUN_AS_USER)s:%(ENV_RUN_AS_USER)s   ; Ensure the regular user owns the socket

[supervisord]
identifier=supervisor               ; Instance name used in RPC/identification.
directory=%(here)s                  ; chdir here just before daemonizing; affects relative paths if set (unset by default).
pidfile=./logs/supervisord.pid      ; File holding the PID of the supervisord process.
nodaemon=true                       ; Run in background (false) or stay in foreground (true). Foreground is handy for debugging/containers.
silent=false                        ; Hide console output when nodaemon=true (rarely needed).
; environment=                      ; Extra environment variables for ALL child processes, e.g. KEY1="v1",KEY2="v2" (none by default).
; minfds=1024                       ; Minimum required file descriptors; refuse to start if the system has fewer available.
; minprocs=200                      ; Minimum required process slots; refuse to start if the system has fewer available.
; umask=022                         ; Default permission mask inherited by child processes (can be overridden per [program]).
; user=app                          ; Drop privileges of supervisord itself to this user after startup (unset by default).
; --- Logging ---
childlogdir=./logs                  ; The directory containing the logs of individual child programs/services.
; nocleanup=false                   ; If true, do not remove old AUTO child logs at startup (leave false unless you need to keep them).
logfile=./logs/supervisord.log      ; Where supervisord writes its OWN logs (not child program logs).
logfile_maxbytes=50MB               ; Rotate the supervisord log when it exceeds this size. Use 0 to disable rotation.
logfile_backups=10                  ; How many rotated supervisord logs to keep (ignored when logfile_maxbytes=0).
loglevel=info                       ; Log verbosity: critical|error|warn|info|debug|trace (impl-dependent; common are: critical..debug).
; strip_ansi=false                  ; If true, strip ANSI color codes from supervisord’s own logs.

; Allows remote control of the Supervisor via RPC (e.g. supervisorctl).
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

; Configure the supervisorctl client to use the same socket as supervisord.
[supervisorctl]
serverurl=unix://%(ENV_SUPERVISOR_SOCK)s    ; Point supervisorctl to the per-user UNIX socket

; ------------------------------------------------------------------------------
; --- APPLICATION/SERVICES (MODULES) CONFIGURATION ---
; ------------------------------------------------------------------------------

; [program:example]                             ; Section header: Define ONE service that Supervisor manages. Treat this like a recipe: name it, say what to run, and how to start/stop/restart it.
; command=path_to_executable --arg1 --arg2      ; REQUIRED: What to run. Use full paths to avoid "not found" surprises. Keep the app in foreground (no daemon mode).
; process_name=%(program_name)s                 ; Name of the service that will be displayed in the supervisor.
;                                               ; For MANY copies (numprocs>1), append the copy number so each is unique, e.g.:
;                                               ; process_name=%(program_name)s_%(process_num)02d -> e.g.: example_01, example_02, etc.
; numprocs=1                                    ; How many identical copies to run. Use >1 for simple parallelism (same command multiple times).
; numprocs_start=0                              ; First number used for %(process_num)s. 0 means cout from 0, (0, 1, 2, ...).
; directory=path_to_work_directory              ; Before starting, change into this folder. Handy when your command expects to run from a specific place.
; user=app                                      ; Run as specified user (drops root). Safer. If you leave this out, it runs as the same user as supervisord.
; umask=022                                     ; Default file permissions for files created by this program. 022 = owner can write, others read-only.
;                                               ; Mask Explanation:
;                                               ;   A = owner mask, B = group mask, C = others mask.
;                                               ; Value Explanation:
;                                               ;   0 -> remove nothing (keep rwx as allowed by default),
;                                               ;   1 -> remove x       (no execute/search)
;                                               ;   2 -> remove w       (no write)
;                                               ;   3 -> remove w+x     (no write, no execute/search)
;                                               ;   4 -> remove r       (no read)
;                                               ;   5 -> remove r+x     (no read, no execute/search)
;                                               ;   6 -> remove r+w     (no read, no write)
;                                               ;   7 -> remove r+w+x   (remove everything for that class)
; environment=KEY1="value 1",KEY2="value 2"     ; Extra environment variables for this program. Format: NAME="value", comma-separated.
; autostart=true                                ; Start automatically when supervisord starts. Set false if you want to start it manually later.
; startsecs=1                                   ; After starting, the program must stay alive for this many seconds to count as “started OK”.
; startretries=3                                ; If it keeps dying during startup, try this many times before giving up (marked as FATAL).
; autorestart=unexpected                        ; What to do after it has been running and then exits:
;                                               ; - true: always restart (even clean exits)
;                                               ; - false: never auto-restart
;                                               ; - unexpected: restart only if exit code is NOT in exitcodes
; exitcodes=0                                   ; Which exit codes are considered “clean” (no restart when autorestart=unexpected). Comma-separated list.
; stopsignal=TERM                               ; Signal used on `supervisorctl stop`. TERM asks politely. Use KILL only if everything else fails.
; stopwaitsecs=10                               ; How long to wait after stopsignal before sending KILL (force stop). Increase if your app needs more time to shut down.
; stopasgroup=false                             ; true - send stopsignal to the whole process group (parent AND children). Use when your app spawns helpers that must stop too.
; killasgroup=false                             ; true - when forcing stop (KILL), also kill the whole process group. Often paired with stopasgroup=true.
; priority=999                                  ; Start/stop order. Lower starts earlier and stops later. Use smaller numbers for core dependencies.
; redirect_stderr=false                         ; true - merge STDERR into STDOUT so you only manage one log stream (stdout). Simple, but you lose separation of errors.
; stdout_logfile=./logs/program_name.out        ; Where normal prints go (STDOUT). Use a file for persistence. To print to console: /dev/stdout (not typical on bare metal).
; stdout_logfile_maxbytes=50MB                  ; When the stdout log grows past this size, rotate it (set 0 to disable rotation).
; stdout_logfile_backups=10                     ; How many rotated stdout files to keep (older ones are deleted).
; stdout_capture_maxbytes=0                     ; Keep a small recent chunk of STDOUT in memory for event notifications (0 = off).
; stdout_events_enabled=false                   ; true - emit PROCESS_LOG_STDOUT events that listeners can react to.
; stderr_logfile=./logs/program_name.err        ; Where error prints go (STDERR). Ignored if redirect_stderr=true. To console: /dev/stderr.
; stderr_logfile_maxbytes=50MB                  ; Rotate stderr log after this size (0 = no rotation).
; stderr_logfile_backups=10                     ; How many rotated stderr files to keep.
; stderr_capture_maxbytes=0                     ; Keep a small recent chunk of STDERR in memory for events (0 = off).
; stderr_events_enabled=false                   ; true - emit PROCESS_LOG_STDERR events for listeners.

; --------------------------------------------------------------
; NOTE: We run regular programs as a non-root user for security.
; The user is passed from launch.sh via ENV_RUN_AS_USER.
; --------------------------------------------------------------

[program:supervisor_service]
command=%(ENV_VIRTUAL_ENV)s/bin/python -u -m supervisor_service.app
process_name=%(program_name)s
directory=%(here)s
user=%(ENV_RUN_AS_USER)s            ; Drop privileges for this service (runs as regular user).
environment=PYTHONUNBUFFERED="1"    ; PYTHONUNBUFFERED: Force Python to print logs immediately (no buffering)
autostart=true                      ; Autostart.
startsecs=10                        ; Time for a complete service startup.
startretries=3                      ; Restart n times before FATAL (gave up).
autorestart=unexpected              ; Restart after unknown exit code.
exitcodes=0                         ; Known exit codes.
stopasgroup=true                    ; Stops all services in this group.
killasgroup=true                    ; Forces stopping all services in this group.
priority=20
; --- Logging ---
redirect_stderr=true                ; Merge STDERR and STDOUT into one output.
stdout_logfile=./logs/supervisor_service.log
stdout_logfile_maxbytes=0
stderr_logfile_backups=0
; stderr_logfile=./logs/supervisor_service.err
; stderr_logfile_maxbytes=0
; stderr_logfile_backups=0

[program:auth_service]
command=%(ENV_VIRTUAL_ENV)s/bin/python -u -m auth_service.app
process_name=%(program_name)s
directory=%(here)s
user=%(ENV_RUN_AS_USER)s            ; Drop privileges for this service (runs as regular user).
environment=PYTHONUNBUFFERED="1"    ; PYTHONUNBUFFERED: Force Python to print logs immediately (no buffering)
autostart=true                      ; Autostart.
startsecs=10                        ; Time for a complete service startup.
startretries=3                      ; Restart n times before FATAL (gave up).
autorestart=unexpected              ; Restart after unknown exit code.
exitcodes=0                         ; Known exit codes.
stopasgroup=false                   ; DO NOT stop all services in this group after stopping this service.
killasgroup=false                   ; DO NOT force stop all services in this group after stopping this service.
priority=30
; --- Logging ---
redirect_stderr=true                ; Merge STDERR and STDOUT into one output.
stdout_logfile=./logs/auth_service.out
stdout_logfile_maxbytes=0
stderr_logfile_backups=0
; stderr_logfile=./logs/auth_service.err
; stderr_logfile_maxbytes=0
; stderr_logfile_backups=0

;[program:email_service]
;command=%(ENV_VIRTUAL_ENV)s/bin/python -u -m email_service.app
;process_name=%(program_name)s
;directory=%(here)s
;user=%(ENV_RUN_AS_USER)s            ; Drop privileges for this service (runs as regular user).
;environment=PYTHONUNBUFFERED="1"    ; PYTHONUNBUFFERED: Force Python to print logs immediately (no buffering)
;autostart=true                      ; Autostart.
;startsecs=10                        ; Time for a complete service startup.
;startretries=3                      ; Restart n times before FATAL (gave up).
;autorestart=unexpected              ; Restart after unknown exit code.
;exitcodes=0                         ; Known exit codes.
;stopasgroup=false                   ; DO NOT stop all services in this group after stopping this service.
;killasgroup=false                   ; DO NOT force stop all services in this group after stopping this service.
;priority=50
;; --- Logging ---
;redirect_stderr=true                ; Merge STDERR and STDOUT into one output.
;stdout_logfile=./logs/email_service.out
;stdout_logfile_maxbytes=0
;stderr_logfile_backups=0
;; stderr_logfile=./logs/email_service.err
;; stderr_logfile_maxbytes=0
;; stderr_logfile_backups=0

;[program:info_service]
;command=%(ENV_VIRTUAL_ENV)s/bin/python -u -m info_service.app
;process_name=%(program_name)s
;directory=%(here)s
;user=%(ENV_RUN_AS_USER)s            ; Drop privileges for this service (runs as regular user).
;environment=PYTHONUNBUFFERED="1"    ; PYTHONUNBUFFERED: Force Python to print logs immediately (no buffering)
;autostart=true                      ; Autostart.
;startsecs=10                        ; Time for a complete service startup.
;startretries=3                      ; Restart n times before FATAL (gave up).
;autorestart=unexpected              ; Restart after unknown exit code.
;exitcodes=0                         ; Known exit codes.
;stopasgroup=false                   ; DO NOT stop all services in this group after stopping this service.
;killasgroup=false                   ; DO NOT force stop all services in this group after stopping this service.
;priority=60
;; --- Logging ---
;redirect_stderr=true                ; Merge STDERR and STDOUT into one output.
;stdout_logfile=./logs/info_service.out
;stdout_logfile_maxbytes=0
;stderr_logfile_backups=0
;; stderr_logfile=./logs/info_service.err
;; stderr_logfile_maxbytes=0
;; stderr_logfile_backups=0

;[program:io_service]
;command=%(ENV_VIRTUAL_ENV)s/bin/python -u -m io_service.app
;process_name=%(program_name)s
;directory=%(here)s
;user=%(ENV_RUN_AS_USER)s            ; Drop privileges for this service (runs as regular user).
;environment=PYTHONUNBUFFERED="1"    ; PYTHONUNBUFFERED: Force Python to print logs immediately (no buffering)
;autostart=true                      ; Autostart.
;startsecs=10                        ; Time for a complete service startup.
;startretries=3                      ; Restart n times before FATAL (gave up).
;autorestart=unexpected              ; Restart after unknown exit code.
;exitcodes=0                         ; Known exit codes.
;stopasgroup=false                   ; DO NOT stop all services in this group after stopping this service.
;killasgroup=false                   ; DO NOT force stop all services in this group after stopping this service.
;priority=70
;; --- Logging ---
;redirect_stderr=true                ; Merge STDERR and STDOUT into one output.
;stdout_logfile=./logs/io_service.log
;stdout_logfile_maxbytes=0
;stderr_logfile_backups=0
;; stderr_logfile=./logs/io_service.err
;; stderr_logfile_maxbytes=0
;; stderr_logfile_backups=0

;[program:control_service]
;command=%(ENV_VIRTUAL_ENV)s/bin/gunicorn control_site.wsgi:application --chdir %(here)s/control_service --workers 2 --bind 127.0.0.1:8080
;process_name=%(program_name)s
;directory=%(here)s
;user=%(ENV_RUN_AS_USER)s            ; Drop privileges for this service (runs as regular user).
;environment=PYTHONUNBUFFERED="1"    ; PYTHONUNBUFFERED: Force Python to print logs immediately (no buffering).
;autostart=true                      ; Autostart.
;startsecs=10                        ; Time for a complete service startup.
;startretries=3                      ; Restart n times before FATAL (gave up).
;autorestart=unexpected              ; Restart after unknown exit code.
;exitcodes=0                         ; Known exit codes.
;stopasgroup=false                   ; DO NOT stop all services in this group after stopping this service.
;killasgroup=false                   ; DO NOT force stop all services in this group after stopping this service.
;priority=40
;; --- Logging ---
;redirect_stderr=true                ; Merge STDERR and STDOUT into one output.
;stdout_logfile=./logs/control_service.out
;stdout_logfile_maxbytes=0
;stderr_logfile_backups=0
;; stderr_logfile=./logs/control_service.err
;; stderr_logfile_maxbytes=0
;; stderr_logfile_backups=0

; ------------------------------------------------------------------------------
; --- GROUPS CONFIGURATION ---
; ------------------------------------------------------------------------------

[group:RaspberryPiSystem]
programs=supervisor_service,auth_service
;email_service,info_service,io_service,control_service

; ------------------------------------------------------------------------------
; --- EVENT LISTENERS CONFIGURATION ---
; ------------------------------------------------------------------------------
; The eventlistener is a process that listens for Supervisor events.

; [eventlistener:example]                               ; Section header: define an EVENT LISTENER pool (process(es) that subscribe to Supervisor events).
; command=path_to_executable --arg1 --arg2              ; REQUIRED: What to run (the listener). Use full path. Must speak the Supervisor eventlistener protocol.
; process_name=%(program_name)s                         ; Name template shown by supervisorctl (include %(process_num)s if numprocs>1).
; numprocs=1                                            ; How many identical listener processes to start in the pool.
; numprocs_start=0                                      ; First index used for %(process_num)s (0,1,2,…).
; events=PROCESS_STATE,TICK_60                          ; REQUIRED: Comma-separated event types to subscribe to (e.g. PROCESS_STATE,TICK_60). No default. See docs for valid types.
; buffer_size=10                                        ; Listener pool queue size (when full, oldest events are dropped), Default is 64 KB (65536).
; result_handler=supervisor.dispatchers:default_handler ; Python entry-point string handling OK/FAIL results (advanced; default is fine).
; directory=path_to_work_directory                      ; Before starting, change into this folder. Handy when your command expects to run from a specific place.
; user=app                                              ; Run as specified user (drops root). Safer. If you leave this out, it runs as the same user as supervisord.
; umask=022                                             ; Default file permissions for files created by this program. 022 = owner can write, others read-only.
; environment=KEY1="value 1",KEY2="value 2"             ; Extra environment variables for this program. Format: NAME="value", comma-separated.
; autostart=true                                        ; Start automatically when supervisord starts. Set false if you want to start it manually later.
; startsecs=1                                           ; After starting, the program must stay alive for this many seconds to count as “started OK”.
; startretries=3                                        ; If it keeps dying during startup, try this many times before giving up (marked as FATAL).
; autorestart=unexpected                                ; What to do after it has been running and then exits: true/false/unexpected.
; exitcodes=0                                           ; Which exit codes are considered “clean” (no restart when autorestart=unexpected). Comma-separated list.
; stopsignal=TERM                                       ; Signal used on `supervisorctl stop`. TERM asks politely. Use KILL only if everything else fails.
; stopwaitsecs=10                                       ; How long to wait after stopsignal before sending KILL (force stop). Increase if your app needs more time to shut down.
; stopasgroup=false                                     ; true - send stopsignal to the whole process group (parent AND children). Use when your app spawns helpers that must stop too.
; killasgroup=false                                     ; true - when forcing stop (KILL), also kill the whole process group. Often paired with stopasgroup=true.
; priority=999                                          ; Start/stop order. Lower starts earlier and stops later. Use smaller numbers for core dependencies.
; redirect_stderr=false                                 ; true - merge STDERR into STDOUT so you only manage one log stream (stdout). Simple, but you lose separation of errors.
; stdout_logfile=AUTO                                  ; Where STDOUT goes (AUTO = childlogdir). For listeners, keep stdout for protocol only; log to STDERR.
; stdout_logfile_maxbytes=50MB                          ; When the stdout log grows past this size, rotate it (set 0 to disable rotation).
; stdout_logfile_backups=10                             ; How many rotated stdout files to keep (older ones are deleted).
; stdout_events_enabled=false                           ; true - emit PROCESS_LOG_STDOUT events that listeners can react to (won’t work in capture mode).
; stderr_logfile=AUTO                                   ; Where STDERR goes (use this for listener’s own logs).
; stderr_logfile_maxbytes=50MB                          ; Rotate stderr log after this size (0 = no rotation).
; stderr_logfile_backups=10                             ; How many rotated stderr files to keep.
; stderr_events_enabled=false                           ; Emit PROCESS_LOG_STDERR events.

[eventlistener:event_listener]
; IMPORTANT: this listener intentionally DOES NOT set 'user=' so it runs as root.
; It needs root privileges to execute nginx_init.sh / nginx_stop.sh when rules trigger actions.
command=%(ENV_VIRTUAL_ENV)s/bin/python ./supervisor_service/listeners/event_listener.py
process_name=%(program_name)s
directory=%(here)s
environment=PYTHONPATH=%(here)s,PYTHONUNBUFFERED="1"    ; PYTHONUNBUFFERED: Force Python to print logs immediately (no buffering).
events=PROCESS_STATE, SUPERVISOR_STATE_CHANGE           ; Events to capture.
buffer_size=1024                                        ; Listener pool queue size (when full, oldest events are dropped).
autostart=true                                          ; Autostrart.
startsecs=10                                            ; Time for a complete service startup.
startretries=3                                          ; Restart n times before FATAL (gave up).
autorestart=true                                        ; Autorestart.
stopsignal=TERM                                         ; Signal used on `supervisorctl stop`. TERM asks politely. Use KILL only if everything else fails.
stopwaitsecs=40                                         ; Wait for the final script to finish
stopasgroup=false                                       ; DO NOT stop all services in this group after stopping this service.
killasgroup=false                                       ; DO NOT force stop all services in this group after stopping this service.
priority=10
; --- Logging ---
stdout_logfile=/dev/null                                ; Ignore READY/START output.
stderr_logfile=/dev/stderr                              ; Output to console.
stderr_logfile_maxbytes=0                               ; Turned off rotation to prevent "Illegal seek".